#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
#include <list>

/*
Собственный алгоритм split, который может разбить любой диапазон данных, используя в качестве 
разделителя каждое включение конкретного значения, и скопировать полученный результат в выходной диапазон данных.
*/

using namespace std;

/*
Цикл требует выполнять перебор до конца входного диапазона данных. 
Во время каждой итерации вызов std::find используется для поиска следующего элемента
входного диапазона, который равен split_val. В нашем случае этот элемент — дефис ('-'), 
поскольку мы хотим разбить входную строку на фрагменты, находящиеся между дефисами. 
Следующая позиция дефиса теперь сохраняется в slice_end. После перебора цикла итератор it 
перемещается на следующий после искомого элемент. Таким образом, цикл перескакивает от дефиса 
к дефису вместо того, чтобы проходить по отдельным элементам.
В данной комбинации итератор it указывает на начало последнего slice, а slice_end — на конец последней вырезки. 
Оба итератора отмечают начало и конец поддиапазона данных, который представляет собой ровно одну вырезку между двумя символами дефиса. 
Для строки "foo-bar-baz" это значит, что у нас будет три итерации цикла и всякий раз мы будем получать пару итераторов, 
которые окружают одно слово. Но нам нужны не итераторы, а подстроки. Бинарная функция bin_func помогает их получить. 
При вызове функции split мы передали ей следующую бинарную функцию:
[](auto it_a, auto it_b) {
return string(it_a, it_b);
}
Функция split пропускает каждую пару итераторов через функцию bin_func, прежде чем отправить их в конечный итератор. 
От функции bin_func мы получим строки "foo", "bar" и "baz".
*/
template <typename InIt, typename OutIt, typename T, typename F>
InIt split(InIt it, InIt end_it, OutIt out_it, T split_val, F bin_func)
{
    while (it != end_it) {
        auto slice_end(find(it, end_it, split_val));
        *out_it++ = bin_func(it, slice_end);

        if (slice_end == end_it) { return end_it; }
        it = next(slice_end);
    }
    return it;
}

int main()
{
    const string s{ "a-b-c-d-e-f-g" };

    auto binfunc([](auto it_a, auto it_b) {
        return string(it_a, it_b);
        });

    list<string> l;

    split(begin(s), end(s), back_inserter(l), '-', binfunc);

    copy(begin(l), end(l), ostream_iterator<string>{cout, "\n"});

    return 0;
}