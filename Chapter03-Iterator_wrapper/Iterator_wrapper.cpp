#include <iostream>
#include <string>
#include <iterator>
#include <sstream>
#include <deque>

// Использование оберток итераторов для заполнения обощенных структур данных
/*
std::back_insert_iterator
В адаптер back_insert_iterator можно обернуть типы std::vector, std::deque, std::list и т. д. 
Он будет вызывать метод контейнера push_back, который вставит новый элемент после всех существующих элементов. 
Если объект контейнера недостаточно велик, то его размер увеличится автоматически.
std::front_insert_iterator
Адаптер front_insert_iterator делает то же самое, что и адаптер back_insert_iterator, 
но вызывает метод контейнера push_front, который вставляет новый элемент перед существующими. 
Обратите внимание: для контейнеров наподобие std::vector это значит, что все существующие элементы нужно сдвинуть 
на одну позицию вправо для освобождения места под новый элемент.
std::insert_iterator
Этот адаптер итератора аналогичен другим итераторам вставки, но может вставлять новые элементы между существующими. 
Вспомогательная функция std::inserter, которая создает подобную оболочку, принимает два аргумента. Первый — контейнер, 
а второй — итератор, указывающий на позицию, в которую будут вставлены новые элементы.
std::istream_iterator
Адаптер istream_iterator тоже довольно удобен. Он подходит для любого объекта std::istream (который может представлять 
собой стандартный поток ввода или файлы) и будет пытаться преобразовывать полученные данные в соответствии с параметром шаблона. 
В этом примере мы использовали конструкцию std::istream_iterator<int>(std::cin), получающую из потока ввода целые числа.
Как правило, мы не знаем длину потока. Это оставляет открытым вопрос: куда указывает конечный итератор, если нам неизвестно, 
где заканчивается поток? Суть в том, что итератор знает, когда достигает конца потока. При сравнении с конечным итератором он 
фактически не будет сравнивать себя с конечным итератором, но даст знать, остались ли токены в потоке. Именно поэтому конструктор 
конечного итератора не принимает никаких аргументов.
std::ostream_iterator
Адаптер ostream_iterator аналогичен адаптеру istream_iterator, но работает по обратному принципу: не принимает токены из потока ввода, 
а отправляет их в поток вывода. Еще одно отличие заключается в том, что его конструктор принимает второй аргумент, являющийся строкой, 
которая будет помещена в поток вывода после каждого элемента. Это полезно, поскольку таким способом можно вывести на экран разделяющую запятую ", " 
или символ перехода на новую строку.
*/


using namespace std;

int main()
{
	// подходит для любого объекта std::istream (который может представлять собой стандартный поток ввода или файлы) 
	// и будет пытаться преобразовывать полученные данные в соответствии с параметром шаблона
	// так как длина входящего потока как правило неизвестна, то конечный итератор указывается пустым (istream_iterator знает когда заканчивается поток)
	istream_iterator<int> it_cin{ cin };
	istream_iterator<int> end_cin;

	deque<int> v;
	// back_inserter автоматически вставляет в конец 
	// эта оболочка итератора по сути выполняет метод push_back 
	// для каждого элемента полученного из потока ввода
	copy(it_cin, end_cin, back_inserter(v));

	istringstream sstr{ "123 456 789" };
	// делаем указатель на середину деки
	auto deque_middle(next(begin(v), static_cast<int>(v.size()) / 2));
	// используем inserter чтобы указать место вставки
	// адаптер insert_iterator позволяет делать вставку между элементами
	copy(istream_iterator<int>{sstr}, {}, inserter(v, deque_middle));

	initializer_list<int> il2{ -1, -2, -3 };
	// front_inserter соответственно вставляет в начало деки, использует метод push_front
	// Обратите внимание: для контейнеров наподобие std::vector это значит, что все 
	// существующие элементы нужно сдвинуть на одну позицию вправо для освобождения места под новый элемент.
	copy(begin(il2), end(il2), front_inserter(v));
	// ostream_iterator итератор вывода - перенаправляет данные в cout и разделяет запятой
	copy(begin(v), end(v), ostream_iterator<int>{cout, ", "});
	cout << '\n';
}