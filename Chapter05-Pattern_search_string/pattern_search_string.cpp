#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
#include <functional>

/*
std::search - по сути поиск одного диапазона в другом, можно использовать для контейнеров всех видов
Начиная с c++17 у нее есть дополнительный интерфейс, позволяющий легко заменять алгоритм поиска, в т.ч. можно делать кастомные
*/

/*
std::default_searcher — выполняет переадресацию к устаревшей реализации std::search;
std::boyer_moore_searcher — использует поисковый алгоритм Бойера — Мура;
std::boyer_moore_horspool_searcher — по аналогии применяет алгоритм Бойера — Мура — Хорспула.
*/

/*
Алгоритм Бойера — Мура разрабатывали, опираясь на конкретную идею: шаблон поиска сравнивается со строкой, 
начиная с конца шаблона и двигаясь справа налево. Если символ в строке для поиска отличается от символа шаблона 
на перекрывающихся позициях и даже не встречается в шаблоне, то становится очевидно, что последний можно сместить 
в строке поиска на количество позиций, равное его длине.

этот алгоритм мог бы стать алгоритмом поиска по умолчанию, если бы вам не пришлось идти на компромиссы. 
Он работает быстрее алгоритма по умолчанию, но его следует использовать для структур данных быстрого поиска, 
чтобы определить, какие символы содержатся в шаблоне поиска и насколько они смещены. Компилятор выберет их 
сложную реализацию в зависимости от типов данных, хранящихся в шаблоне (они могут варьироваться от ассоциативных 
массивов, основанных на хеше, для сложных типов до примитивных справочных таблиц для типов наподобие char). 
В конечном счете это значит следующее: реализация поиска по умолчанию будет более быстрой при условии, что 
поисковая строка не слишком велика. Если сам поиск занимает много времени, то использование алгоритма Бойера — Мура 
может привести к повышению производительности в измерении постоянного коэффициента.
Алгоритм Бойера — Мура — Хорспула является упрощением описанного алгоритма Бойера — Мура. В нем нет правила о плохом символе, 
что приводит к сдвигу всей длины шаблона, если искомый символ не встречается в найденной строке. Компромисс в принятии такого 
решения заключается в том, что первый алгоритм работает несколько медленнее, чем второй, но в процессе ему требуется меньше 
структур данных.
*/

using namespace std;

template <typename Itr>
static void print(Itr it, size_t chars)
{
    copy_n(it, chars, ostream_iterator<char>{cout});
    cout << '\n';
}

int main()
{
    const string long_string{ "Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod" };
    const string needle{ "elitr" };

    {
        auto match(search(begin(long_string), end(long_string),
            begin(needle), end(needle)));
        print(match, 5);
    }

    {
        auto match(search(begin(long_string), end(long_string),
            default_searcher{ begin(needle), end(needle) }));
        print(match, 5);
    }

    {
        auto match(search(begin(long_string), end(long_string),
            boyer_moore_searcher{ begin(needle), end(needle) }));
        print(match, 5);
    }

    {
        auto match(search(begin(long_string), end(long_string),
            boyer_moore_horspool_searcher{ begin(needle), end(needle) }));
        print(match, 5);
    }
}